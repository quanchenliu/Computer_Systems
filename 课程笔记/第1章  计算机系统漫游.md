# 第一章  计算机系统漫游



## 一、从 C 语言程序 到 可执行目标程序：

**1、一个 C 语言程序如下：**

```C
#include <stdio.h>
int main(){
	printf("Hello World!");
    return 0;
}
```

​	通常而言 ， 程序是**以字节序列**的方式存储在文件中的，且对中英文符合敏感。因此，使用 ASCII 码来完成代码中的**字符到整数值的转化**。

​	我们将只由 ASCII 字符构成的文件称为**文本文件**，所有其他文件都称为二进制文件。

​	事实上，在计算机内部，系统中所有的信息都以**二进制的形式存储**。而唯一可行的区分不同数据对象的方法就是**上下文**。

**2、预处理器：**

​	预处理器根据文本文件的开头（以字符 '#' 开头的命令），修改原始程序。

​	在上述程序中，读取了系统头文件 stdio.h 的内容，并将之直接插入程序文本中，从而得到了一个**新的程序**。通常以 `.i` 作为文件的扩展名。

**3、编译阶段：**

​	编译器将 文本文件 hello.i 翻译成文本文件 hello.s，这实际上是一个**汇编语言程序**。

**4、汇编阶段：**

​	汇编器将汇编语言程序翻译成**机器语言指令**，并将这些指令打包成一个**可重定位目标程序**， 并存储于*二进制文件 hello.o* 中。	

**5、链接阶段：**

​	系统将程序中会使用到的头文件以某种方式合并到我们的二进制文件 hello.o 程序中，从而生成 **可执行文件**。

![image-20240512200051535](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240512200051535.png)

## 二、如何执行一个可执行文件的

**1、要理解运行可执行程序时发生了什么，首先需要了解计算机系统的硬件组织：**

（1）总线：在各个设备之间进行信息传递；

（2）I/O设备：系统与用户交互的接口；这里区别一下**控制器**与**适配器**：

- 控制器：I/O 系统本身 或 系统主板上的芯片组；
- 适配器：一块插在主板插槽上的卡；

（3）主存：存放程序和数据，由 DRAM 和 SRAM 组成；

（4）处理器（CPU）：解释或执行指令的引擎；这里区别一下处理器的**指令集架构**与**微体系架构**：

- 指令集架构：描述每条机器指令的效果；
- 微体系架构：描述每条机器指令是如何实现的；



![image-20240512200426219](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240512200426219.png)

**2、执行可执行文件：**从磁盘上读取 hello 文件至主存，CPU开始依次指令相应的指令。

**3、如何利用高速缓存提高程序的性能：**第6章。

**4、存储系统层次结构：**略。



## 三、存储系统层次结构：

### 1、高速缓存：

（1）高速缓存Cache：根据局部性原理，存放处理器近期可能需要的信息。

（2）三级高速缓存：

- L1：容量：数万字节，速度：同寄存器，材质：SRAM；
- L2：容量：数十万~数百万字节，速度：比L1慢5倍，比访问主存快 5~10倍，材质：SRAM；
- L3：容量更大、速度更慢但比主存更快；

（3）**程序员有效地使用高速缓存能够使得程序性能提高一个量级**。

### 2、层次结构：

![image-20240517210349183](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240517210349183.png)



## 四、操作系统：

### 1、操作系统：

任何应用程序对硬件的操作都必须通过操作系统实现。操作系统有两个基本功能：

- 防止硬件被失控的应用程序滥用；
- 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备；

操作系统通过几个抽象概念来实现这两个功能：

- 文件：对 I/O设备的抽象；
- 虚拟内存：对主存和磁盘 I/O设备的抽象；
- 进程：对处理器、主存、I/O设备的抽象；

### 2、几个抽象概念：

**（1）进程：**略

**（2）线程：**略

**（3）虚拟内存：** 提供了一个进程独占内存的假象。每个进程看到的内存都是**一致的**，称为虚拟地址空间。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240517211903247.png" alt="image-20240517211903247" style="zoom: 80%;" />

我们从最低的地址开始，从下往上介绍：

- *只读代码和数据 ：*对所有进程来说，**代码**是从同一固定地址开始的，紧接着是**全局变量**对应的数据位置。其后是读写数据，这两部分的内容是**根据可执行目标文件的内容初始化**的。代码和数据区在进程一**开始运行时**就被指定了大小。
- *堆* ：当调用类似于 malloc 、free 、new、delete 等库函数时，堆可以在运行时**动态的**扩展和收缩。
- *共享库* ：大约在地址空间的**中间部分**，用于存放像C标准库和数学库等共享库的代码和数据的区域；这部分内容相当难懂。
- *栈*：位于用户虚拟地址空间顶部的是用户栈，编译器用它来**实现函数调用**。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。比较常见的是函**数栈帧**——调用一个函数，栈就会增长；一个被调函数返回时，栈就会收缩。
- *内核虚拟内存* ：地址空间顶部的区域是为内核保留的，**不允许**应用程序读写这个区域的内容或者直接调用内核代码定义的函数。

**（4）文件：**

- 文件，就是**字节序列**。因此，任何 I/O设备都是文件。
- 系统的所有输入输出都是通过一个 **Unix I/O的系统函数**调用读写文件来实现的。
- 文件这个概念的提出，使得应用程序有了一个**统一的视图**来看待系统中各式各样的 I/O设备；



## 五、一些重要的内容：

### 1、Amdahl's Law（阿姆达尔定律）

Gene Amdahl进行了一个富有洞察力的观察： **提升一个系统的一个部分的性能对整个系统有多大影响**， 即：Amdahl's Law。(**注：**这里的**系统**，可指**计算机系统**或别的什么系统)

当提升系统的一部分性能时，对整个系统性能的影响取决于：

1. 这一部分有多重要；
2. 这一部分性能提升了多少。

假设原来在一个系统中执行一个程序需要时间 ![T_{old}](https://www.zhihu.com/equation?tex=T_%7Bold%7D&consumer=ZHI_MENG) ，其中某一个部分占的时间百分比为 ![\alpha](https://www.zhihu.com/equation?tex=%5Calpha&consumer=ZHI_MENG) ，然后，把这一部分的性能提升 ![k](https://www.zhihu.com/equation?tex=k&consumer=ZHI_MENG) 倍。即这一部分原来需要的时间为 ![\alpha T_{old}](https://www.zhihu.com/equation?tex=%5Calpha+T_%7Bold%7D&consumer=ZHI_MENG) ，现在需要的时间变为 ![(\alpha T_{old})/k](https://www.zhihu.com/equation?tex=%28%5Calpha+T_%7Bold%7D%29%2Fk&consumer=ZHI_MENG) 。则整个系统执行此程序需要的时间变为：

![T_{new}=(1-\alpha)T_{old} + (\alpha T_{old})/k =T_{old}[(1-\alpha) + \alpha /k]](https://www.zhihu.com/equation?tex=T_%7Bnew%7D%3D%281-%5Calpha%29T_%7Bold%7D+%2B+%28%5Calpha+T_%7Bold%7D%29%2Fk+%3DT_%7Bold%7D%5B%281-%5Calpha%29+%2B+%5Calpha+%2Fk%5D&consumer=ZHI_MENG)

故可得，系统性能提速的倍数为: ![S=\frac{1}{(1-\alpha)+\alpha/k}](https://www.zhihu.com/equation?tex=S%3D%5Cfrac%7B1%7D%7B%281-%5Calpha%29%2B%5Calpha%2Fk%7D&consumer=ZHI_MENG) 。

举例：某个系统的某个部分的执行时间占总执行时间的60%，即 ![\alpha = 0.6 ](https://www.zhihu.com/equation?tex=%5Calpha+%3D+0.6+&consumer=ZHI_MENG) ，这部分性能提升3倍( ![k=3](https://www.zhihu.com/equation?tex=k%3D3&consumer=ZHI_MENG) )，则

​			整个系统的性能提升为![1/[0.4+0.6/3]=1.67](https://www.zhihu.com/equation?tex=1%2F%5B0.4%2B0.6%2F3%5D%3D1.67&consumer=ZHI_MENG) 倍。

可以看出**即使一个系统的==主要部分==(main part)性能提升了很多，==整个系统的性能提升远远小于此部分的提升==**。把上面的例子极端化一下，把那部分性能的提升从 3 倍改为到无穷大倍，即 ![k=\infty](https://www.zhihu.com/equation?tex=k%3D%5Cinfty&consumer=ZHI_MENG) ，这部分能瞬间执行完，则： ![S_{\infty}=\frac{1}{(1-\alpha)}=\frac{1}{1-0.6}=2.5](https://www.zhihu.com/equation?tex=S_%7B%5Cinfty%7D%3D%5Cfrac%7B1%7D%7B%281-%5Calpha%29%7D%3D%5Cfrac%7B1%7D%7B1-0.6%7D%3D2.5&consumer=ZHI_MENG) 倍，远小于 ![\infty](https://www.zhihu.com/equation?tex=%5Cinfty&consumer=ZHI_MENG) 。

### 2、并发与并行：

并发，指一个同时具有多个活动的系统。并行，用并发来使一个系统运行得更快。我们通常强调**三个层次的并发**：

1. **线程级并发：** 使用线程使得我们可以在一个进程中执行多个控制流，允许多个用户同时与系统交互

   - 单处理器系统：处理器即使在多个任务之间切换，但实际的计算是由一个处理器完成的；
   - 多处理器系统：将多个CPU（核）集成到一个芯片上，每个核都有自己独立的 L1、L2 高速缓存，其中 **L1 分为 数据Cache 和 指令Cache**；L3 高速缓存由**所有核共享**。
   - 超线程（同时多线程，simultaneous multi-threading）：允许一个CPU执行多个控制流的技术，相较于常规处理器需要约20000个时钟周期做不同线程间的转换，超线程能够在**单周期内决定要执行哪个线程**。

   多处理器可以从两个方面提高系统性能：首先，减少了在执行多个任务时模拟并发的需要；其次，使应用程序运行得更快（要求程序是以多线程方式编写的）。

2. **指令级并行：** 现代处理器都可以**同时执行多条指令的属性**就叫指令级并行

   - 在传统的处理器上，一般都是多个时钟周期处理一条指令；而在最近的处理器中，基本可以保持**每个时钟周期处理2~4条指令**的执行速率。
   - 事实上，每条指令从开始执行到结束需要很长的时间，约20个或更多的时钟周期，但是处理器使用了流水线技术，将一条指令的执行划分成了若干不同的阶段（常见的是五段式流水线），以此来实现指令的并行。
   - **超标量（super-scalar）**处理器：以**高于**一个时钟周期一条指令的速率执行指令。

3. **单指令、多数据并行：** 一条指令产生多个可以并行执行的操作，这种方式就是单指令多数据并行，又称 **SIMD并行**

   - 提供 SIMD 指令是为了提高处理**影像、声音和视频数据**的执行速度；
   - 一种可靠的方法是：使用**编译器支持的特殊向量数据类型**来写程序

### 3、抽象在计算机系统中的重要性：

​	抽象是计算机科学中一个非常重要的概念。例如：指令集架构，它提供了一个对实际处理器硬件的抽象。通过这个抽象，机器代码在执行过程中表现得就好像是在一个一次只执行一条指令的处理器上。事实上，在底层硬件执行时，它并行地执行多条指令，但又与那个简单有序的模型保持一致，因此：只要模型一致，不同的处理器（Inter / AMD）实现也能**执行同样的机器代码，而又提供不同的开销和性能**。















