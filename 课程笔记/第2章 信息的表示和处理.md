## 第二章 信息的表示和处理

**本章内容概览：**

1. **整数的表示**：
   - 无符号数的表示：略。
   - 有符号数的表示：有符号数用补码表示。
   - **无符号数与有符号数之间的转换**：见 2. 4 
   - 扩展与截断；

2. **整数的运算：**
   - 无论是无符号加法还是补码加法，其运算过程均相同：**位级表达式直接相加，若产生溢出，则直接截断，保留低 w 位即可**。
   - 无论是无符号乘法还是补码乘法，其运算过程均相同：**先用十进制计算出结果，然后将其转为 无符号二进制串或补码 表示，最后保留低 w 位**。
   - **移位运算与加法运算的结合**来提升乘法和除法的速度。
   - 无符号数的逆元：
   - 有符号数的逆元：除 $TMin_w$ 外，其余的值：从右往左数第一个 1 的左边**所有位**按位取反。 

3. **IEEE 浮点数格式标准；**
   - IEEE 754 浮点数标准；
   - 浮点数

4. **==根据计算机的算术运算的特性来编写可靠的程序！！！==**



## 一、信息存储：

### 1、十六进制表示法：

**（1）为什么会有十六进制表示法：**二进制太冗长、十进制与位模式的相互转化很麻烦，因此引入 十六进制（4个二进制位）；

**（2）一个重要的数制转换机制：** 十进制--二进制--十六进制；

### 2、字大小：

**（1）字长：**每台计算机都有一个字长（word size），用于标明指针数据的标称大小（nominal size）。一般而言，字长决定最重要的系统参数就是**虚拟地址空间大小**。

**（2）32 位程序与 64 位程序：** 32 位程序与 64 位程序的区别在于：该程序是如何编译的，而不是其运行的机器类型。

**（3）一些变量声明的注意事项：**

- **char 类型**的变量也是可以用于**存储整数值**的。
- 通常情况下，程序员应使用**有符号字符的声明**来保证一个字节的有符号数值。*非特殊要求，不使用 unsigned 来对变量进行无符号声明*。
- **可移植性**是程序员编写程序时应该考虑的最关键的问题之一，这就要求程序员需要使用**确定大小的数据类型**。`int32_t` 、 `int64_t` 是一种新的数据类型，其数据大小是固定的，不随编译器、机器设置而发生变化，分别为 4B和8B。使用确定大小的整数类型是程序员精确控制数据表示的最佳途径。

### 3、寻址与字节顺序：

**（1）寻址：**通常而言，跨越多字节的程序对象、数据对象在内存中都是**连续存储**的，而其地址为所占地址空间的**最小地址**。

**（2）存储方式：**在实际应用中，数据的存储方式分为两类：

- 大端存储：一种符合人类阅读习惯的存储方式；
- 小端存储：一种符合计算机运算规则的存储方式；

​		许多最近推出的处理器使用的是**双端法**：允许用户把它们配置成大端存储、小端存储方式运行。而实际情况是，一旦选择了**特定的操作系统**，那么字节顺序也就随之确定。在所有的手机操作系统中，Android 、iOS、鸿蒙等，都**只支持小端方式**。

**（3）字节存储顺序所带来的影响：**对于大多数程序员而言，机器所使用的字节顺序是完全不可见的，因为无论是哪种机器所编译的程序都会得到同样的结果，但是在以下几种情况下，字节顺序会变为一个很重要的问题：

- **在不同类型的机器之间通过网络传送二进制数据时**：这要求程序员在编写网络应用程序的代码时必须遵守已建立的字节顺序的规则。
- **对程序进行反汇编时：**尤其是在涉及到内存地址问题、计算问题时，字节顺序将直接关系到参与运算的数据大小；
- **==编写规避正常的类型系统的程序时：==**

**（4）一个 `printf` 与 `cout` 的区别：**

```C++
int main() {
    int x = 1024;
    int* p = &x;
    char* start = (char*)&x;
    size_t len = sizeof(int);
    std::cout << *p << std::endl;			//1024
    for (size_t i = 0; i < len; i++) {		//00 04 00 00
        std::cout << std::setw(2) << std::setfill('0') << std::hex << (int)(unsigned char)start[i] << " ";
    }
    std::cout << std::endl;
    std::cout << x << std::endl;			//400
    printf("%d\n", x);						//1024
    std::cout << x << std::endl;			//400
    return 0;
}
```

而下面的程序，仅仅只是**将循环中的输出方式进行了改变**，结果却完全不一样：

```C++
int main() {
    int x = 1024;
    int* p = &x;
    char* start = (char*)&x;
    size_t len = sizeof(int);
    std::cout << *p << std::endl;			//1024
    for (size_t i = 0; i < len; i++) {		//00 04 00 00
        printf("%.2x", start[i]);
    }
    std::cout << std::endl;
    std::cout << x << std::endl;			//1024
    printf("%d\n", x);						//1024
    std::cout << x << std::endl;			//1024
    return 0;
}
```

==**原因分析：**==



### 4、表示字符串：

（1）在 C / C++ 中，字符串被编码为一个**以 '\n' (又称为 null) 结尾的字符数组**。因此，字符数组的长度 = 其元素个数 + 1。

​		  值得注意的是，在使用 ASCII 码作为字符串的任何系统上，对同一字符的编码数值都是相同的，因此文本数据比二进制数据具有更强的**平台独立性**。

**（2）Unicode标准：**使用 32 位来表示字符，但这并不绝对。例如：对于英文字符，Unicode 编码兼容 ASCII 码的编码方案；对于一些常用的中文字符，仅需 2~3字节 就可以表示，而一些不太常用的字符才使用 4字节 来表示；其他文字的字符编码方案也同中文。

### 5、表示代码：

​		事实上，对于同样的一个程序，在不同的机器上，会**得到完全不一样的机器指令代码**。这是因为不同的机器类型使用不同且不兼容的指令和编码方式，因此即使是完全一样的进程（注意！是进程而不仅是程序），运行在不同的操作系统上也会有不同编码规则——即：**二进制代码是不兼容的**。

​		之所以会有这样的差异，是因为从计算机机器的角度来看，**程序仅仅是字节序列**。

### ==6、布尔代数：==

**（1）布尔代数：** 

**（2）布尔环：** 

**（3）布尔运算：** 

**（4）位向量的运算：**   



### 7、位、逻辑、移位运算：

**（1）位运算：** C / C++ 支持按位布尔运算，|（或）、&（且）、~（非）、^（异或）。确定一个位运算表达式结果的最好方法：将 x 进制**转换为二进制**表示，然后执行位运算，最后再转回 x 进制。

**（2）逻辑运算：** 逻辑运算符 ||（或）、&&（且）、！（非）。逻辑运算符与位运算符非常容易相混淆，但是它们的功能是完全不同的：

- 逻辑运算认为所有非零参数都是 TRUE，参数零则表示 FALSE；
- 逻辑运算符规定：若确定第一个参数的值就能确定表达式的结果，则不会计算第二个参数的值；
- 只有当按位运算的参数被限制为0或1时，才和其对应的逻辑运算有相同的行为。

**（3）移位运算：** 

- `<<` （左移运算符）：x 向左移动 k 位，低位补 0 ；
- `>>`（右移运算符）：C / C++ 语言标准并未规定有符号数应该使用哪种右移。
  - 逻辑右移：高位补0；默认**无符号数使用逻辑右移**。
  - 算术右移：高位补最高位的值；默认**有符号数使用算术右移**。
- 看，当**要移动的位数 $k ≥ w$** 时（w 为数据类型的位数）：移位指令只考虑位移量的低 $k * log_2 w$ 位，即实际上的**位移量 = $k \  mod\ w$** 
- **移位运算符的优先级：**把握不住运算符优先级时，可以灵活地使用 `()` 来为表达式确定优先级顺序。



## 二、整数的表示：

### 1、一些常见的符号及其对应的运算：

![image-20240521172522800](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240521172522800.png)

### 2、无符号数的编码：

**（1）两种整数编码方式：**在计算机中，编码整数有两种方式，一种是编码无符号数（非负），一种是编码有符号数（通常用补码表示）。

**（2）无符号数的编码：**所谓无符号数的编码，就是将一个只含0、1的二进制序列映射为一个非负整数。

- 通常我们认为，一个 n 位的二进制串，可以**唯一**映射成一个介于 $0$ ~ $2^n-1$ 之间的整数。 即：**无符号数编码具有唯一性**。
- 无符号数的编码范围：$[0, 2^{n} -1 ]$ 

### 3、有符号数的编码：

**（1）补码的定义：** 

众所周知，有符号数在计算机以**补码**（Two‘s Complement）的形式存在。

- 在计组中，我们是这样介绍补码的：首先介绍原码，按位求反得到反码，反码末尾加1得到补码。因此我们有一种较为方便的由原码求补码的计算方法：**符号位不变，右边第一个 1 的左侧按位取反，右侧不变**。

- 在这里，我们介绍一种**==新的补码定义方法==**：对于一个二进制向量 $\vec{x} = [x_{n-1}, x_{n-2}, ..., x_1, x_0]$ ，其补码定义为：

$$
B2T_w(\vec{x}) = -x_{n-1}*2^{n-1} + \sum_{i=0}^{n-2} x_i2^i
$$

​		这种新的定义方式，方便了我们**直接由 $[x]_补$ 得到 $x$ 的真值。**

- 补码的编码范围：$[-2^{n-1}, 2^{n-1}-1]$。显然补码的范围是**不对称**的，这是因为**一半的位模式用来表示负数，一半的位模式用来表示非负数**，而 0 是非负数，因此能表示的正数比负数少一个。
- 补码编码同样具有**唯一性**，即：补码0只有一种表示方法。

**（2）原码和反码的定义：**

- 原码（Sign-Magnitude）：最高有效位是符号位，以此来确定剩下的位是正权还是负权
  $$
  B2S_w(\vec{x}) = (-1)^{x_{n-1}}*\sum_{i=0}^{n-2} x_i2^i
  $$
  
- 反码（Ones’ Complement）：最高有效位的权为 $ -(2^{n-1}-1)$ 而不是 $-2^{n-1}$ 
  $$
  B2O_w(\vec{x}) = -x_{n-1}*(2^{n-1}-1) + \sum_{i=0}^{n-2} x_i2^i
  $$

- 

- 请注意，反码（Ones’ Complement）和补码（Two‘s Complement）中撇号的位置是不同的。这来源于这样的一种情况：对于非负数 $x$ ，
  - 我们用 $2^n-x$ （这里只有一个2）计算 $-x$ 的 n 位补码表示；
  - 我们用 $[111...1] - x$ （这里有很多个1）来计算 $-x$ 的反码表示；

### ==4、有符号数与无符号数之间的转换：==

事实上，有符号数与无符号数之间的转换原则是，**底层的二进制串不变，对二进制串的解释方式改变**。

**（1）有符号数转换为无符号数（相同字长）：** 由于绝大多数编译器都使用补码来表示有符号数，因此给出**==补码转换为无符号数==**

​		  对满足 $TMin_n ≤ x ≤ TMax_n$ 的 $x$ 有：
$$
T2U_n(x) = 
\begin{cases}
 x + 2^n, & x<0\\
 x,& x≥0
\end{cases}
$$
​		 显然，当一个有符号数映射为它相应的无符号数时，负数被转换成了更大的正数，**非负数则保持不变**。

**（2）无符号数转换为有符号数（相同字长）：** 对满足 $0≤x≤UMax_n$ 的 $x$ 有：
$$
U2T_n(x) = 
\begin{cases}
 x, & x≤TMax_n\\
 x-2^n,& x > TMax_n
\end{cases}
$$
​			其中，$TMax_n = 2^{n-1}-1$ 。

**（3）总结：** 



![image-20240521192050429](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240521192050429.png)

### 5、C / C++中的有符号数与无符号数：

（1）C / C++ 中默认对有符号数用补码表示，且对大多数数字都默认为有符号数。要**创建一个无符号常量，必须加上后缀 'u' 或 'U'**。

（2）C / C++ 允许有符号数和无符号数进行转换，通常有两种转换方式：

- 显式：强制转换；
- 隐式：当一种类型的表达式被赋值给另一种类型的变量时，转换是隐式发生的。
- 特别地，**当一个有符号数与无符号数同时参加一个运算时，会隐式地将有符号数转换为无符号数**，并假设这两个数都是非负的。

（3）为什么在 `limits.h` 文件中，INT_MIN要定义为 -INT_MAX-1 而不是直接定义为 0x80000000

- **可移植性：**直接使用 `0x80000000` 作为 `INT_MIN` 的定义可能在一些平台上不起作用，**并不是所有平台都使用二进制补码来表示负数**；
- **符号的正确性：**在处理不同位宽的系统时，直接使用 `0x80000000` 表达 `INT_MIN` 的方式可能会引起符号和类型转换的问题，。例如，32位系统中可以直接使用 `0x80000000` 表示 `-2147483648`，但是在16位或64位系统中，这种硬编码的值可能会导致错误（因为会发生**截断和扩展**）。

因此，我们在 limits.h 文件中用以下的方式定义 TMax、Tmin。同时，这给我们在编程时提供了一个崭新的思路，我们应该**==使用 `-TMax-1` 来表示有符号数的最小值==**。

```C++
#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
```

### 6、扩展和截断：

**（1）扩展：** 无符号数进行 **零扩展**（zero extension），即：在开头补0；有符号数进行 **符号扩展**（sign extension），即在开头补最高位的数值。

**（2）截断： ** 事实上，从位运算的层面来说，截断就是保留低 k 位。但是显然问题不在于如何截断，而在于截断之后如何对数据进行解释。

- 无符号数：直接去原数值的低 k 位；
- 有符号数：$B2T_k(\vec{x}) = U2T_k(B2U_n(\vec{x}) mod 2^k)$ ，即：**将原来的值视为无符号数**，然后 **$mod 2^k$**，再将结果**转为补码**（字长为 k ，而不是 n ）。



## 三、整数的运算：

### 1、无符号数加法：

我们考虑这样的两个数相加 $0≤x, y<2^n$ ，则有：$0 ≤ x+y ≤2^{n+1} -2$ 。这样的结果意味着我们需要对字长进行扩展（n →n+1）。因此一些编程语言（如：Lisp）支持无限精度的运算，允许任意整数的运算。然而更常见的是，编程语言支持**固定精度的运算**，因而“加法”和“乘法”这样的运算不同于它们在整数上的相应运算。

我们定义这样一种运算 $+^u_w$ ：
$$
x +^u_w y = 
\begin{cases}
x+y,&x+y<2^w\\
x+y-2^w, &2^w≤x+y<2^{w+1}
\end{cases}
$$
**通俗一点理解就是**：对于 $w$ 位的两个无符号整数 $x、y$，若 $x+y$ 需要用 $w+1$ 位来表示（溢出），则截断高位，仅**保留低 $w$ 位**的值；否则不做改变。

通常情况下，C / C++ 程序中都不会将算术溢出作为错误而发信号，但是有些时候我们会希望**判断是否发生了溢出**。显然，如果 $s=x+y$ 没有溢出，我们能够肯定 $s ≥ x$；否则 $s < x$。

==**补充：无符号的非(无符号逆元)**==

​		我们定义：对满足$0≤x<2^w$的 $x$，其补码的非 $-^u_w x$ 由下式给出：
$$
-^u_w x = 
\begin{cases}
x , & x = 0\\
2^w-x , & x > 0
\end{cases}
$$

### 2、补码加法：

我们定义补码加法如下：对于满足$-2^{w-1} ≤x,y≤2^{w-1}-1$的整数 $x、y$有：
$$
x +^t_w y = 
\begin{cases}
x+y, & -2^{w-1} ≤x+y<2^{w-1} &正常\\
x+y-2^w, & 2^{w-1} ≤x+y &正溢出\\
x+y+2^w, & -2^{w-1}>x+y &负溢出\\
\end{cases}
$$
根据上式，我们可以很容易地得到**溢出判断**：

- 当且仅当$x>0,y>0,且s≤0$ 时，发生正溢出；
- 当且仅当$x<0,y<0,且s≥0$ 时，发生负溢出；

事实上，补码加法和无符号数的加法**具有完全相同的位级表示**，而大多数的计算机使用同样的机器指令来执行补码加法和无符号数加法。

![image-20240522191024668](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240522191024668.png)

**==补充：补码的非==**

​		我们定义：对满足$Tmin_w≤x≤TMax_w$的 $x$，其补码的非 $-^t_w x$ 由下式给出：
$$
-^t_w x = 
\begin{cases}
TMin_w , & x = TMin_w\\
-x , & x > TMin_w
\end{cases}
$$
​		一种快速由**补码的位级表示**得到该**补码的非的位级表示**方法：从右往左数，第一个 1 的**左边所有位取反**（包括符号位）。

### 3、无符号乘法：

两个 $w$ 位的无符号数 $x、y$的乘积 $x*y$ 可能需要 $2w$ 位来表示，因此直接将乘积截断，**保留低 $w$ 位**作为乘法的结果。因此，我们在自己计算无符号乘法时，可以先将 $x、y$ 扩展到 $2w$ 位，然后计算其乘积，若高 $w$ 位 不全为0，则截断，仅保留低 $w$ 位。

### 4、补码乘法：

事实上，补码乘法与无符号乘法具有**相同的位级表示**。为了理解的简单起见，我们可以按照如下的原则计算补码乘法：

- 将二进制补码 $x_2、y_2$ 转换成**十进制数** $x_10、y_10；$
- 然后**计算** $x_10*y_10 = s$；
- 将 $s$ 转换为**二进制原码**，然后转换成**二进制补码**。

### 5、乘以常数：

由于乘法指令通常都需要非常多的指令周期，因此编译器使用了一项重要的优化：用 **移位+加法运算** 的组合来代替常数因子的乘法。我们首先考虑2的幂的乘法，其次考虑其他常数的乘法。

**（1）乘以2的幂：**

- **左移**一位，等于执行**一个**与2的幂相乘的**无符号**乘法；
- 对固定字长的无符号数**左移 k 位，其高 k 位丢弃**。
- 与2的幂相乘的补码乘法：**与无符号乘法具有相同的位级表示**；

**（2） 乘以任意常数：**

- 例如：$14 = 2^3 + 2^2 + 2^1$，因此编译器将乘法重写为：`(x<<3)+(x<<2)+(x<<1) ` 
- 无论 x 是无符号还是补码，甚至当乘法会导致溢出时，两个计算都具有**相同的位级表示**。

### 6、除以2的幂：

通常来说，整数除法的速度比整数乘法更慢，但是也可以通过移位来实现。**无符号数与补码数分别使用逻辑移位和算术移位来达到目的**。整数除法总是舍入到零，为了准确进行定义，我们认为：$\lfloor a \rfloor$ 为唯一的整数 $a'$ ，使得 $a' ≤ a < a'+1$ .

**（1）无符号数除法：** 对无符号数 x 和 k， 且 $0≤k<w$，则有 $x/2^k = \lfloor (x>>k)\rfloor$   （**逻辑移位**）

**（2）补码发除法：** 对补码 x 和无符号数 k， 且 $0≤k<w$，则有 $x/2^k = \lfloor (x>>k)\rfloor$   （**算术移位**）

- 事实上，进行算术右移来计算除法，最后的结果是**向下取整**；
- 当我们希望**直接舍弃小数部分**时：对于$x / 2^k$ 
  - 令 $x = x+2^k-1$ ，然后执行 `x>>k` 算术移位运算。



## 四、浮点数：

### 1、二进制小数：

与十进制表示法类似，十进制不能准确表示 1/3、pi 等数的值。二进制表示法也只能表示那些能够被写成 $ x * 2^y $ 的数，其它值只能被近似地表示（不过，增加二进制表示的长度可以提高表示的精度）。

注意：形如 `0.111...11` 的二进制数串表示的是**刚好小于 1** 的数。通常使用 $1-\varepsilon$ 来简单表示这样的数值。

### 2、IEEE 754 标准:

IEEE 浮点数标准用 $V = (-1)^s * M * 2^E$ 的形式来表示一个数。符号 s，阶码 E，尾数 M。这三个字段有两种最常见的格式：

- 单精度浮点数（float）：1 位，8 位，23 位；
- 双精度浮点数（double）：1 位，11 位， 52 位；

![image-20240524175559588](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240524175559588.png)

根据阶码部分的值的不同，被编码的值可以分为以下**三种情况**：

![image-20240524175608900](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240524175608900.png)

#### （1）规格化数：

- 特征：$exp$ 的位模式既不全为 0，也不全为 1；
- **阶码** $E = e - Bias$：$e$ 为 $exp$ 的无符号数；$Bias$ 为**偏置**，值为 $2^{k-1} -1$；
- 小数字段 $frac$ 被解释为 $f$，其中 $0 ≤ f < 1$。小数字段**隐含以 1 开头**的整数部分。即：**尾数** $M = 1 + f$；

#### （2）非规格化数：

- 特征：$exp$ 的位模式全 0 ；
- 阶码 $E = 1 - Bias$，尾数 $M = f$；或者 阶码 $E = - Bias$，尾数 $M = 1 - f$；
  - 上面两种规定模式，使得我们能够完成最大非规格化数和最小规格化数之间的平滑转变。
- 非规格化数的用途：
  - **表示数值 0** 的方法，注意 +0、-0 的位级表示是不一样的。
  - 表示那些非常**接近 0.0 的数**。

#### （3）特殊值：

- 特征：$exp$ 的位模式全 1 
  - 小数域全 0：表示无穷，正负由最高位决定；无穷通常可用于**表示结果超过最大规格化数**的结果。
  - 小数域非零：表示 “NaN”，即“不是一个数”；可以用于表示一些**非实数、非无穷、未初始化**的数。

#### （4）浮点数示例：

下表给出了一个 8 位浮点格式的示例，4 位阶码位，3 位小数域。

![image-20240524181127663](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240524181127663.png)

当我们将上面表格中的位表示解释为**无符号整数**，它们是按照**升序**排列的。这并不是偶然，而是浮点数规则设计的目的，从而使得浮点数能够使用整数排序函数来进行排序和比较大小。

当处理负数时，由于开头有 1 ，因此它们是按照**降序**来排序的。不过，同样不需要浮点运算来进行比较。==作业 2.84==

### 3、舍入：

比较常见的有四种舍入方法：

- **向偶数舍入（round-to-even）**：将数字向上或向下舍入，使得结果的最低有效数字是偶数。默认的舍入方式。
- 向零舍入方式：正数向下舍入，负数向上舍入。
- 向下舍入方式：都向下舍入。
- 向上舍入方式：都向上舍入。

计算机默认使用向偶数舍入的舍入方式，是因为它**以50%的概率向上舍入，以50%的概率向下舍入**。而其余三种舍入方式都会以更大可能造成均值误差的增大。下面我们介绍向偶数舍入的具体方法：

- 若是舍入到整数：只需要保证舍入之后的结果，其**个位是偶数**即可。
- 若是舍入到小数点后若干位：
  - 若最低有效位为 0 则为偶数，最低有效位为 1 则为奇数。
  - 若待舍入的值表示在两个确定的结果的正中间的值：
    - 形如：`XXXXXX.YYYYYY1000....` ，其中 X 、Y表示任意位值，**最右边的 Y 是要保留的精度**。
    - 对于满足要求的数，我们倾向于**使最右边的 Y 为零**。
- 一个示例：考虑舍入到最近的四分之一（二进制小数点右边2位）
  - $10.00011_2$ ：介于$10.000_2$ ~ $10.001_2$  之间，向下舍入为$10.00_2$ 
  - $10.00110_2$ ：介于$10.001_2$ ~ $10.01_2$  之间，向上舍入为$10.01_2$ 
  - $10.11100_2$ ：等于 $10.111_2$ ，向上舍入为 $11.00_2$ 
  - $10.10100_2$ ：等于 $10.101_2$ ，向下舍入为 $10.10_2$ 

### 4、浮点运算：

浮点运算的结果只需要精确到能够保证得到一个正确的舍入结果就可以了，可以独立于任何具体的硬件或软件实现。

**（1）浮点加法：**

- 浮点加法也形成了**阿贝尔群**；
- 加法具有交换律，但**没有结合律**；特别地，**浮点加法具有单调性属性**（若 $a≥b$，则对任意的a、b、x，除了 NaN，都有$x+a≥x+b$），这是无符号或补码加法所不具备的。
- **逆元：**绝大部分的值在浮点加法下都有逆元，即：$x +^f -x = 0$，但无穷、NaN是例外情况。（$+∞-∞ = NaN$，$NaN +^f x = NaN$，x 为任意的值）

**（2）浮点乘法：**

- 浮点乘法具有交换律，但**没有结合律**；特别地，浮点乘法具有**单调性**属性。


**（3）没有结合律的影响：** 程序员在写程序时，必须要**考虑到两个浮点数运算的先后顺序**，必须保证浮点运算的结果是我们所希望的结果，而不会因运算顺序问题导致溢出等问题使得结果出现意外错误。



## 五、一些有助于理解有关概念的习题：



















